package cs.mad.pantree.Entities

import android.content.Context
import android.content.Intent
import android.util.Log
import androidx.core.content.ContextCompat.startActivity
import androidx.room.*
import cs.mad.pantree.Activities.IngredientInputActivity
import cs.mad.pantree.Activities.RecipeListActivity
import cs.mad.pantree.WebServices.RecipeWebservice
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.Serializable
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response



//API Recipe, store its id(from the api), title, image, list of missed ingredient(API ingredients) and list of used ingredients
@Serializable
data class APIRecipe (
    val id: Int,
    val title: String,
    val image: String,
    val usedIngredients: List<APIIngredient>,
    val missedIngredients: List<APIIngredient>

)

//database recipe, made using a companion function to APIRecipe that is super beefy
//stores an autogenerated id, the recipes outside id for pulling its sourceUrl(api wants to rip us off smh), title, image url, and the source url
@Entity
data class Recipe (
    @PrimaryKey (
        autoGenerate = true
    ) var id: Long? = null,
    val outsideId: Int,
    val title: String,
    val image: String,
    val sourceUrl: String
        )

//beefiest function in the whole app, try best not to mess with. Is called when we use apiCall() in the searchRecipe on click listener
//first, this does a second API call to grab the sourceUrl for a recipe (again they're ripping us off)
//after that, it does some crazy wizardy while turning an API recipe into a normal recipe, basically creates all the ingredients
//for a given recipe by using the toIngredient function of the APIIngredient entity. It then maps the id of the recipe
//to all the ingredients in that recipe so we can pull them for our shopping list
//it takes in the recipeDao and ingredientDao and does all the database inserting here
//finally, it checks to make sure that we're on the last recipe before launching the recipe list activity (THIS IS WHERE WE'RE HAVING ISSUES)
fun APIRecipe.storeInDatabase(rcpDao: RecipeDao, ingDao: IngredientDao, context: Context, complete:()-> Unit) {

    //anonymously makes the urlService pull
    RecipeWebservice().recipeUrlService.pullRecipe(this.id, "f645e9e38de842cfa8a46a4346419b2f").enqueue(object:
        Callback<SourceUrl> {
        override fun onResponse(
            call: Call<SourceUrl>,
            response: Response<SourceUrl>
        ) {
            //if successful,
            if (response.isSuccessful) {
                Log.d("onResponse url", "download success!")
                val url = response.body()

                //makes a new recipe with the intended source url
                val rcp = url?.let { Recipe(null, id, title, image, it.sourceUrl) }

                //if recipe is not null, inserts it into database
                runOnIO {
                    if (rcp != null) {
                        rcp.id = rcpDao.insert(rcp)
                    }
                }

                //for each ingredient we already have in the recipe
                for (usedIngredient in usedIngredients) {
                    //if the recipe is not null
                    if (rcp != null) {
                        //calls the to ingredient function and passes in the recipe id for referencing the ingredients later
                        rcp.id?.let {
                            var ing = usedIngredient.toIngredient(it)

                            //inserts the ingredient into the database
                            runOnIO {
                                ingDao.insert(ing)
                            }
                        }
                    }
                }

                //for each ingredient we don't already have
                for (missedIngredient in missedIngredients) {
                    //if the recipe is not null
                    if (rcp != null) {
                        //calls the to ingredient function and passes in the recipe id for referencing the ingredients later
                        rcp.id?.let {
                            var ing = missedIngredient.toIngredient(it)

                            //sets the ingredients missed field to true (for marking checkboxes)
                            ing.missed = true

                            //inserts the ingredient into the database
                            runOnIO {
                                ingDao.insert(ing)
                            }
                        }
                    }

                }

                //if we're on the final index
                complete()

            }

        }

        //onFailure
        override fun onFailure(call: Call<SourceUrl>, t: Throwable) {
            Log.d("onFailure url", "failed")
        }
    })





//standard dao with two additional functions:
// getRecipe returns a recipe where the outsideId is matching, this is set up incorrectly as its supposed to be outsideId =: outsideId
//I don't think I ever actually called getRecipe() and can't find it in any of the code, but it says that its being used and right now
//the app is working mostly as intended, so I am petrified at the thought of removing it

//getRecipeById is what I think I getRecipe to be, but I do actually use this one. I pull a recipe by id when grabbing its url in the shopping
//list activity to launch in the webview
}
@Dao
interface RecipeDao {
    @Query("select * from recipe")
    suspend fun getAll(): List<Recipe>

    @Query("select * from recipe where outsideId = outsideId")
    suspend fun getRecipe(): Recipe

    @Query("select * from recipe where id = :id")
    suspend fun getRecipeById(id: Long): Recipe

    @Insert
    suspend fun insert(rcp: Recipe) : Long //returns type

    @Insert
    suspend fun insertAll(rcps: List<Recipe>)

    @Update(onConflict = OnConflictStrategy.REPLACE)
    suspend fun update(rcp: Recipe)

    @Delete
    suspend fun delete(rcp: Recipe)

    @Query("delete from recipe")
    suspend fun deleteAll()

}

fun runOnIO(lambda: suspend () -> Unit) {
    runBlocking {
        launch(Dispatchers.IO) { lambda() }
    }
}

/*

 */